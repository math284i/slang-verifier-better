// -----------------------------------------
// Runtime model
// Notice that we can hold at most one permission
// to *fields*, but this does not apply to *predicates*
predicate time_credit() // represents one abstract unit of time

// models spending an abstract unit of time 
// needs to be called at the beginning of every method
// and loop iteration
method consume_time_credit() // 
    requires acc(time_credit(), 1/1)
// -----------------------------------------

// -----------------------------------------
// Object model
// The provided fields are required.
// You can add additional (ghost) fields
// if you want

// a BST node
field elem : Int // value stored in the node
field left : Ref // left child
field right : Ref // right child

// Object for the whole BST, which just stores a 
// pointer to the root node of the tree
field root: Ref 
// -----------------------------------------


// -----------------------------------------
// Utility functions, which you may find useful
function max(a : Int, b : Int) : Int 
    ensures result >= a && result >= b
    ensures result == a || result == b
{
    a > b ? a : b
}

function min(a : Int, b : Int) : Int 
    ensures result <= a && result <= b
    ensures result == a || result == b
{
    a < b ? a : b
}
// -----------------------------------------


// -----------------------------------------
// TASK 4.1: Define a predicate for binary search trees and individual BST nodes.
// You may define additional fields, predicates, arguments or heap-based functions.

// The whole tree has just a reference to the root
// The empty tree is represented by self.root == null

predicate bst(self: Ref) {

    //acc(self, 1/1) &&
    acc(self.root, 1/1) &&
    acc(self.elem, 1/1) &&
    acc(self.left, 1/1) && acc(self.right, 1/1) &&
    (self.left != null ==> bst(self.left)) &&
    (self.right != null ==> bst(self.right)) &&
    (bst_node(self.root))
}

// A single BST node. Apart from field permissions, the current value
// must be greater than the largest value in the left subtree and
// smaller than the smallest value in the right subtree.



predicate bst_node(self: Ref) {
    acc(self.elem, 1/1) &&
    acc(self.left, 1/1) &&
    acc(self.right, 1/1) &&
    (
        // Ensure the left subtree's elements are less than the node's value
        (bst_node(self.left)) &&
        forall l: Int :: l in to_set_node(self.left) ==> l < self.elem
    ) &&
    (
        // Ensure the right subtree's elements are greater than the node's value
        (bst_node(self.right)) &&
        forall r: Int :: r in to_set_node(self.right) ==> r > self.elem
    )
}


// -----------------------------------------
// TASK 4.2: Define a data abstraction function that maps
// every BST to the set of values it stores. // TODO
// -----------------------------------------
function to_set(tree: Ref): Set[Int]
    requires acc(bst(tree))
{
    unfolding bst(tree) in (tree.root == null ? Set[Int]() : to_set_node(tree.root))
}

function to_set_node(node: Ref): Set[Int]
    requires acc(bst_node(node))
{
    unfolding bst_node(node) in (node == null
        ? Set[Int]() 
        : to_set_node(node.left) union Set(node.elem) union to_set_node(node.right))
}



// -----------------------------------------
// Auxiliary definition of the height of a tree
function height(tree: Ref) : Int
    requires bst(tree)
    // TODO: define for TASK 4.4
// -----------------------------------------


// -----------------------------------------
// TASK 4.3: Implement the following method and use your predicate ans abstraction function to
//           prove that the method correctly inserts a value into a BST.
//           It is OK to ignore time credits for this task, i.e. you do not have to call consume_time_credit().

// TASK 4.4: Show that h+2 time credits suffice to insert a value into a BST, where h is the height of the tree.
//           For this task, you must call consume_time_credit() at the beginning of every method and for every
//           loop iteration.
method bst_insert(tree: Ref, val: Int)
    requires acc(bst(tree))
    ensures bst(tree)
    ensures to_set(tree) == old(to_set(tree)) union Set(val)
{
    //consume_time_credit() // Consume one unit of time at the start of the method

    if (tree.root == null) {
        // If the tree is empty, create a new node as the root
        var newNode: Ref := new() 
        inhale acc(newNode.elem, 1/1)
        inhale acc(newNode.left, 1/1)
        inhale acc(newNode.right, 1/1)
        newNode.elem := val
        newNode.left := null
        newNode.right := null
        tree.root := newNode
    } else {
        // Insert the value into the tree starting from the root
        bst_insert_node(tree.root, val)
    }
}

method bst_insert_node(node: Ref, val: Int)
    requires bst_node(node)
    ensures bst_node(node)
    //ensures to_set_node(node) == old(to_set_node(node)) union Set(val)
{
    //consume_time_credit() // Consume time credit for entering this recursive function

    if (val < node.elem) {
        if (node.left == null) {
            var newNode: Ref := new()
            inhale acc(newNode.elem, 1/1)
            inhale acc(newNode.left, 1/1)
            inhale acc(newNode.right, 1/1)
            newNode.elem := val
            newNode.left := null
            newNode.right := null
            node.left := newNode
        } else {
            bst_insert_node(node.left, val)
        }
    } if (val > node.elem) {
        if (node.right == null) {
            var newNode: Ref := new()
            inhale acc(newNode.elem, 1/1)
            inhale acc(newNode.left, 1/1)
            inhale acc(newNode.right, 1/1)
            newNode.elem := val
            newNode.left := null
            newNode.right := null
            node.right := newNode
        } else {
            bst_insert_node(node.right, val)
        }
    }
}
